.TH "eeprom.h" 3 "Wed Sep 16 2015" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
eeprom.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'stm32f4xx\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPAGE_SIZE\fP   (uint32_t)0x4000  /* Page size = 16KByte */"
.br
.ti -1c
.RI "#define \fBVOLTAGE_RANGE\fP   (uint8_t)VoltageRange_3"
.br
.ti -1c
.RI "#define \fBEEPROM_START_ADDRESS\fP"
.br
.ti -1c
.RI "#define \fBPAGE0_BASE_ADDRESS\fP   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + 0x0000))"
.br
.ti -1c
.RI "#define \fBPAGE0_END_ADDRESS\fP   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + (\fBPAGE_SIZE\fP \- 1)))"
.br
.ti -1c
.RI "#define \fBPAGE0_ID\fP   FLASH_Sector_1"
.br
.ti -1c
.RI "#define \fBPAGE1_BASE_ADDRESS\fP   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + 0x4000))"
.br
.ti -1c
.RI "#define \fBPAGE1_END_ADDRESS\fP   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + (2 * \fBPAGE_SIZE\fP \- 1)))"
.br
.ti -1c
.RI "#define \fBPAGE1_ID\fP   FLASH_Sector_2"
.br
.ti -1c
.RI "#define \fBPAGE0\fP   ((uint16_t)0x0000)"
.br
.ti -1c
.RI "#define \fBPAGE1\fP   ((uint16_t)0x0001)"
.br
.ti -1c
.RI "#define \fBNO_VALID_PAGE\fP   ((uint16_t)0x00AB)"
.br
.ti -1c
.RI "#define \fBERASED\fP   ((uint16_t)0xFFFF)     /* Page is empty */"
.br
.ti -1c
.RI "#define \fBRECEIVE_DATA\fP   ((uint16_t)0xEEEE)     /* Page is marked to receive data */"
.br
.ti -1c
.RI "#define \fBVALID_PAGE\fP   ((uint16_t)0x0000)     /* Page containing valid data */"
.br
.ti -1c
.RI "#define \fBREAD_FROM_VALID_PAGE\fP   ((uint8_t)0x00)"
.br
.ti -1c
.RI "#define \fBWRITE_IN_VALID_PAGE\fP   ((uint8_t)0x01)"
.br
.ti -1c
.RI "#define \fBPAGE_FULL\fP   ((uint8_t)0x80)"
.br
.ti -1c
.RI "#define \fBNB_OF_VAR\fP   ((uint8_t)160)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "uint16_t \fBEE_Init\fP (void)"
.br
.RI "\fIRestore the pages to a known good state in case of page's status corruption after a power loss\&. \fP"
.ti -1c
.RI "uint16_t \fBEE_ReadVariable\fP (uint16_t VirtAddress, uint16_t *Data)"
.br
.RI "\fIReturns the last stored variable data, if found, which correspond to the passed virtual address\&. \fP"
.ti -1c
.RI "uint16_t \fBEE_WriteVariable\fP (uint16_t VirtAddress, uint16_t Data)"
.br
.RI "\fIWrites/upadtes variable data in EEPROM\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define EEPROM_START_ADDRESS"
\fBValue:\fP
.PP
.nf
((uint32_t)0x08004000) /* EEPROM emulation start address:
                                                  from sector1 : after 16KByte of used
                                                  Flash memory */
.fi
.SS "#define ERASED   ((uint16_t)0xFFFF)     /* Page is empty */"

.SS "#define NB_OF_VAR   ((uint8_t)160)"

.SS "#define NO_VALID_PAGE   ((uint16_t)0x00AB)"

.SS "#define PAGE0   ((uint16_t)0x0000)"

.SS "#define PAGE0_BASE_ADDRESS   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + 0x0000))"

.SS "#define PAGE0_END_ADDRESS   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + (\fBPAGE_SIZE\fP \- 1)))"

.SS "#define PAGE0_ID   FLASH_Sector_1"

.SS "#define PAGE1   ((uint16_t)0x0001)"

.SS "#define PAGE1_BASE_ADDRESS   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + 0x4000))"

.SS "#define PAGE1_END_ADDRESS   ((uint32_t)(\fBEEPROM_START_ADDRESS\fP + (2 * \fBPAGE_SIZE\fP \- 1)))"

.SS "#define PAGE1_ID   FLASH_Sector_2"

.SS "#define PAGE_FULL   ((uint8_t)0x80)"

.SS "#define PAGE_SIZE   (uint32_t)0x4000  /* Page size = 16KByte */"

.SS "#define READ_FROM_VALID_PAGE   ((uint8_t)0x00)"

.SS "#define RECEIVE_DATA   ((uint16_t)0xEEEE)     /* Page is marked to receive data */"

.SS "#define VALID_PAGE   ((uint16_t)0x0000)     /* Page containing valid data */"

.SS "#define VOLTAGE_RANGE   (uint8_t)VoltageRange_3"

.SS "#define WRITE_IN_VALID_PAGE   ((uint8_t)0x01)"

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code\&.
