.TH "utils.h" 3 "Wed Sep 16 2015" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
utils.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSIGN\fP(x)   ((x<0)?\-1:1)"
.br
.ti -1c
.RI "#define \fBUTILS_AGE_S\fP(x)   ((float)chTimeElapsedSince(x) / (float)\fBCH_FREQUENCY\fP)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fButils_step_towards\fP (float *value, float goal, float step)"
.br
.ti -1c
.RI "float \fButils_calc_ratio\fP (float low, float high, float val)"
.br
.ti -1c
.RI "void \fButils_norm_angle\fP (float *angle)"
.br
.ti -1c
.RI "int \fButils_truncate_number\fP (float *number, float min, float max)"
.br
.ti -1c
.RI "float \fButils_map\fP (float x, float in_min, float in_max, float out_min, float out_max)"
.br
.ti -1c
.RI "int \fButils_map_int\fP (int x, int in_min, int in_max, int out_min, int out_max)"
.br
.ti -1c
.RI "void \fButils_deadband\fP (float *value, float tres, float max)"
.br
.ti -1c
.RI "float \fButils_angle_difference\fP (float angle1, float angle2)"
.br
.ti -1c
.RI "float \fButils_middle_of_3\fP (float a, float b, float c)"
.br
.ti -1c
.RI "int \fButils_middle_of_3_int\fP (int a, int b, int c)"
.br
.ti -1c
.RI "void \fButils_sys_lock_cnt\fP (void)"
.br
.ti -1c
.RI "void \fButils_sys_unlock_cnt\fP (void)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define SIGN(x)   ((x<0)?\-1:1)"

.SS "#define UTILS_AGE_S(x)   ((float)chTimeElapsedSince(x) / (float)\fBCH_FREQUENCY\fP)"

.SH "Function Documentation"
.PP 
.SS "float utils_angle_difference (float angle1, float angle2)"
Get the difference between two angles\&. Will always be between -180 and +180 degrees\&. 
.PP
\fBParameters:\fP
.RS 4
\fIangle1\fP The first angle 
.br
\fIangle2\fP The second angle 
.RE
.PP
\fBReturns:\fP
.RS 4
The difference between the angles 
.RE
.PP

.SS "float utils_calc_ratio (float low, float high, float val)"

.SS "void utils_deadband (float * value, float tres, float max)"
Truncate absolute values less than tres to zero\&. The value tres will be mapped to 0 and the value max to max\&. 
.SS "float utils_map (float x, float in_min, float in_max, float out_min, float out_max)"

.SS "int utils_map_int (int x, int in_min, int in_max, int out_min, int out_max)"

.SS "float utils_middle_of_3 (float a, float b, float c)"
Get the middle value of three values
.PP
\fBParameters:\fP
.RS 4
\fIa\fP First value
.br
\fIb\fP Second value
.br
\fIc\fP Third value
.RE
.PP
\fBReturns:\fP
.RS 4
The middle value 
.RE
.PP

.SS "int utils_middle_of_3_int (int a, int b, int c)"
Get the middle value of three values
.PP
\fBParameters:\fP
.RS 4
\fIa\fP First value
.br
\fIb\fP Second value
.br
\fIc\fP Third value
.RE
.PP
\fBReturns:\fP
.RS 4
The middle value 
.RE
.PP

.SS "void utils_norm_angle (float * angle)"
Make sure that 0 <= angle < 360 
.PP
\fBParameters:\fP
.RS 4
\fIangle\fP The angle to normalize\&. 
.RE
.PP

.SS "void utils_step_towards (float * value, float goal, float step)"

.SS "void utils_sys_lock_cnt (void)"
A system locking function with a counter\&. For every lock, a corresponding unlock must exist to unlock the system\&. That means, if lock is called five times, unlock has to be called five times as well\&. Note that chSysLock and chSysLockFromIsr are the same for this port\&. 
.SS "void utils_sys_unlock_cnt (void)"
A system unlocking function with a counter\&. For every lock, a corresponding unlock must exist to unlock the system\&. That means, if lock is called five times, unlock has to be called five times as well\&. Note that chSysUnlock and chSysUnlockFromIsr are the same for this port\&. 
.SS "int utils_truncate_number (float * number, float min, float max)"

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code\&.
