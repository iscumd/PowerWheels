.TH "config" 3 "Wed Sep 16 2015" "Doxygen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
config \- Config
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCHPRINTF_USE_FLOAT\fP   TRUE"
.br
.ti -1c
.RI "#define \fBCORTEX_SIMPLIFIED_PRIORITY\fP   TRUE"
.br
.ti -1c
.RI "#define \fBPORT_IDLE_THREAD_STACK_SIZE\fP   64"
.br
.ti -1c
.RI "#define \fBPORT_INT_REQUIRED_STACK\fP   128"
.br
.in -1c
.SS "Kernel parameters and options"

.in +1c
.ti -1c
.RI "#define \fBCH_FREQUENCY\fP   10000"
.br
.RI "\fISystem tick frequency\&. \fP"
.ti -1c
.RI "#define \fBCH_TIME_QUANTUM\fP   4"
.br
.RI "\fIRound robin interval\&. \fP"
.ti -1c
.RI "#define \fBCH_MEMCORE_SIZE\fP   0"
.br
.RI "\fIManaged RAM size\&. \fP"
.ti -1c
.RI "#define \fBCH_NO_IDLE_THREAD\fP   FALSE"
.br
.RI "\fIIdle thread automatic spawn suppression\&. \fP"
.in -1c
.SS "Performance options"

.in +1c
.ti -1c
.RI "#define \fBCH_OPTIMIZE_SPEED\fP   TRUE"
.br
.RI "\fIOS optimization\&. \fP"
.in -1c
.SS "Subsystem options"

.in +1c
.ti -1c
.RI "#define \fBCH_USE_REGISTRY\fP   TRUE"
.br
.RI "\fIThreads registry APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_WAITEXIT\fP   TRUE"
.br
.RI "\fIThreads synchronization APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_SEMAPHORES\fP   TRUE"
.br
.RI "\fISemaphores APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_SEMAPHORES_PRIORITY\fP   FALSE"
.br
.RI "\fISemaphores queuing mode\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_SEMSW\fP   TRUE"
.br
.RI "\fIAtomic semaphore API\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MUTEXES\fP   TRUE"
.br
.RI "\fIMutexes APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_CONDVARS\fP   TRUE"
.br
.RI "\fIConditional Variables APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_CONDVARS_TIMEOUT\fP   TRUE"
.br
.RI "\fIConditional Variables APIs with timeout\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_EVENTS\fP   TRUE"
.br
.RI "\fIEvents Flags APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_EVENTS_TIMEOUT\fP   TRUE"
.br
.RI "\fIEvents Flags APIs with timeout\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MESSAGES\fP   TRUE"
.br
.RI "\fISynchronous Messages APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MESSAGES_PRIORITY\fP   FALSE"
.br
.RI "\fISynchronous Messages queuing mode\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MAILBOXES\fP   TRUE"
.br
.RI "\fIMailboxes APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_QUEUES\fP   TRUE"
.br
.RI "\fII/O Queues APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MEMCORE\fP   TRUE"
.br
.RI "\fICore Memory Manager APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_HEAP\fP   TRUE"
.br
.RI "\fIHeap Allocator APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MALLOC_HEAP\fP   FALSE"
.br
.RI "\fIC-runtime allocator\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_MEMPOOLS\fP   TRUE"
.br
.RI "\fIMemory Pools Allocator APIs\&. \fP"
.ti -1c
.RI "#define \fBCH_USE_DYNAMIC\fP   TRUE"
.br
.RI "\fIDynamic Threads APIs\&. \fP"
.in -1c
.SS "Debug options"

.in +1c
.ti -1c
.RI "#define \fBCH_DBG_SYSTEM_STATE_CHECK\fP   FALSE"
.br
.RI "\fIDebug option, system state check\&. \fP"
.ti -1c
.RI "#define \fBCH_DBG_ENABLE_CHECKS\fP   FALSE"
.br
.RI "\fIDebug option, parameters checks\&. \fP"
.ti -1c
.RI "#define \fBCH_DBG_ENABLE_ASSERTS\fP   FALSE"
.br
.RI "\fIDebug option, consistency checks\&. \fP"
.ti -1c
.RI "#define \fBCH_DBG_ENABLE_TRACE\fP   FALSE"
.br
.RI "\fIDebug option, trace buffer\&. \fP"
.ti -1c
.RI "#define \fBCH_DBG_ENABLE_STACK_CHECK\fP   FALSE"
.br
.RI "\fIDebug option, stack checks\&. \fP"
.ti -1c
.RI "#define \fBCH_DBG_FILL_THREADS\fP   FALSE"
.br
.RI "\fIDebug option, stacks initialization\&. \fP"
.ti -1c
.RI "#define \fBCH_DBG_THREADS_PROFILING\fP   TRUE"
.br
.RI "\fIDebug option, threads profiling\&. \fP"
.in -1c
.SS "Kernel hooks"

.in +1c
.ti -1c
.RI "#define \fBTHREAD_EXT_FIELDS\fP   /* Add threads custom fields here\&.*/"
.br
.RI "\fIThreads descriptor structure extension\&. \fP"
.ti -1c
.RI "#define \fBTHREAD_EXT_INIT_HOOK\fP(tp)"
.br
.RI "\fIThreads initialization hook\&. \fP"
.ti -1c
.RI "#define \fBTHREAD_EXT_EXIT_HOOK\fP(tp)"
.br
.RI "\fIThreads finalization hook\&. \fP"
.ti -1c
.RI "#define \fBTHREAD_CONTEXT_SWITCH_HOOK\fP(ntp,  otp)"
.br
.RI "\fIContext switch hook\&. \fP"
.ti -1c
.RI "#define \fBIDLE_LOOP_HOOK\fP()"
.br
.RI "\fIIdle Loop hook\&. \fP"
.ti -1c
.RI "#define \fBSYSTEM_TICK_EVENT_HOOK\fP()"
.br
.RI "\fISystem tick event hook\&. \fP"
.ti -1c
.RI "#define \fBSYSTEM_HALT_HOOK\fP()"
.br
.RI "\fISystem halt hook\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Kernel related settings and hooks\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define CH_DBG_ENABLE_ASSERTS   FALSE"

.PP
Debug option, consistency checks\&. If enabled then all the assertions in the kernel code are activated\&. This includes consistency checks inside the kernel, runtime anomalies and port-defined checks\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.RE
.PP

.SS "#define CH_DBG_ENABLE_CHECKS   FALSE"

.PP
Debug option, parameters checks\&. If enabled then the checks on the API functions input parameters are activated\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.RE
.PP

.SS "#define CH_DBG_ENABLE_STACK_CHECK   FALSE"

.PP
Debug option, stack checks\&. If enabled then a runtime stack check is performed\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.PP
The stack check is performed in a architecture/port dependent way\&. It may not be implemented or some ports\&. 
.PP
The default failure mode is to halt the system with the global \fCpanic_msg\fP variable set to \fCNULL\fP\&. 
.RE
.PP

.SS "#define CH_DBG_ENABLE_TRACE   FALSE"

.PP
Debug option, trace buffer\&. If enabled then the context switch circular trace buffer is activated\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.RE
.PP

.SS "#define CH_DBG_FILL_THREADS   FALSE"

.PP
Debug option, stacks initialization\&. If enabled then the threads working area is filled with a byte value when a thread is created\&. This can be useful for the runtime measurement of the used stack\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.RE
.PP

.SS "#define CH_DBG_SYSTEM_STATE_CHECK   FALSE"

.PP
Debug option, system state check\&. If enabled the correct call protocol for system APIs is checked at runtime\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.RE
.PP

.SS "#define CH_DBG_THREADS_PROFILING   TRUE"

.PP
Debug option, threads profiling\&. If enabled then a field is added to the \fCThread\fP structure that counts the system ticks occurred while executing the thread\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
This debug option is defaulted to TRUE because it is required by some test cases into the test suite\&. 
.RE
.PP

.SS "#define CH_FREQUENCY   10000"

.PP
System tick frequency\&. Frequency of the system timer that drives the system ticks\&. This setting also defines the system tick time unit\&. 
.SS "#define CH_MEMCORE_SIZE   0"

.PP
Managed RAM size\&. Size of the RAM area to be managed by the OS\&. If set to zero then the whole available RAM is used\&. The core memory is made available to the heap allocator and/or can be used directly through the simplified core memory allocator\&.
.PP
\fBNote:\fP
.RS 4
In order to let the OS manage the whole RAM the linker script must provide the \fC\fBheap_base\fP\fP and \fC\fBheap_end\fP\fP symbols\&. 
.PP
Requires \fCCH_USE_MEMCORE\fP\&. 
.RE
.PP

.SS "#define CH_NO_IDLE_THREAD   FALSE"

.PP
Idle thread automatic spawn suppression\&. When this option is activated the function \fCchSysInit()\fP does not spawn the idle thread automatically\&. The application has then the responsibility to do one of the following:
.IP "\(bu" 2
Spawn a custom idle thread at priority \fCIDLEPRIO\fP\&.
.IP "\(bu" 2
Change the \fBmain()\fP thread priority to \fCIDLEPRIO\fP then enter an endless loop\&. In this scenario the \fC\fBmain()\fP\fP thread acts as the idle thread\&.
.PP
\fBNote:\fP
.RS 4
Unless an idle thread is spawned the \fC\fBmain()\fP\fP thread must not enter a sleep state\&. 
.RE
.PP

.SS "#define CH_OPTIMIZE_SPEED   TRUE"

.PP
OS optimization\&. If enabled then time efficient rather than space efficient code is used when two possible implementations exist\&.
.PP
\fBNote:\fP
.RS 4
This is not related to the compiler optimization options\&. 
.PP
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_TIME_QUANTUM   4"

.PP
Round robin interval\&. This constant is the number of system ticks allowed for the threads before preemption occurs\&. Setting this value to zero disables the preemption for threads with equal priority and the round robin becomes cooperative\&. Note that higher priority threads can still preempt, the kernel is always preemptive\&.
.PP
\fBNote:\fP
.RS 4
Disabling the round robin preemption makes the kernel more compact and generally faster\&. 
.RE
.PP

.SS "#define CH_USE_CONDVARS   TRUE"

.PP
Conditional Variables APIs\&. If enabled then the conditional variables APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_MUTEXES\fP\&. 
.RE
.PP

.SS "#define CH_USE_CONDVARS_TIMEOUT   TRUE"

.PP
Conditional Variables APIs with timeout\&. If enabled then the conditional variables APIs with timeout specification are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_CONDVARS\fP\&. 
.RE
.PP

.SS "#define CH_USE_DYNAMIC   TRUE"

.PP
Dynamic Threads APIs\&. If enabled then the dynamic threads creation APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_WAITEXIT\fP\&. 
.PP
Requires \fCCH_USE_HEAP\fP and/or \fCCH_USE_MEMPOOLS\fP\&. 
.RE
.PP

.SS "#define CH_USE_EVENTS   TRUE"

.PP
Events Flags APIs\&. If enabled then the event flags APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_EVENTS_TIMEOUT   TRUE"

.PP
Events Flags APIs with timeout\&. If enabled then the events APIs with timeout specification are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_EVENTS\fP\&. 
.RE
.PP

.SS "#define CH_USE_HEAP   TRUE"

.PP
Heap Allocator APIs\&. If enabled then the memory heap allocator APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_MEMCORE\fP and either \fCCH_USE_MUTEXES\fP or \fCCH_USE_SEMAPHORES\fP\&. 
.PP
Mutexes are recommended\&. 
.RE
.PP

.SS "#define CH_USE_MAILBOXES   TRUE"

.PP
Mailboxes APIs\&. If enabled then the asynchronous messages (mailboxes) APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_SEMAPHORES\fP\&. 
.RE
.PP

.SS "#define CH_USE_MALLOC_HEAP   FALSE"

.PP
C-runtime allocator\&. If enabled the the heap allocator APIs just wrap the C-runtime \fCmalloc()\fP and \fCfree()\fP functions\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. 
.PP
Requires \fCCH_USE_HEAP\fP\&. 
.PP
The C-runtime may or may not require \fCCH_USE_MEMCORE\fP, see the appropriate documentation\&. 
.RE
.PP

.SS "#define CH_USE_MEMCORE   TRUE"

.PP
Core Memory Manager APIs\&. If enabled then the core memory manager APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_MEMPOOLS   TRUE"

.PP
Memory Pools Allocator APIs\&. If enabled then the memory pools allocator APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_MESSAGES   TRUE"

.PP
Synchronous Messages APIs\&. If enabled then the synchronous messages APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_MESSAGES_PRIORITY   FALSE"

.PP
Synchronous Messages queuing mode\&. If enabled then messages are served by priority rather than in FIFO order\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. Enable this if you have special requirements\&. 
.PP
Requires \fCCH_USE_MESSAGES\fP\&. 
.RE
.PP

.SS "#define CH_USE_MUTEXES   TRUE"

.PP
Mutexes APIs\&. If enabled then the mutexes APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_QUEUES   TRUE"

.PP
I/O Queues APIs\&. If enabled then the I/O queues APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_REGISTRY   TRUE"

.PP
Threads registry APIs\&. If enabled then the registry APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_SEMAPHORES   TRUE"

.PP
Semaphores APIs\&. If enabled then the Semaphores APIs are included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CH_USE_SEMAPHORES_PRIORITY   FALSE"

.PP
Semaphores queuing mode\&. If enabled then the threads are enqueued on semaphores by priority rather than in FIFO order\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCFALSE\fP\&. Enable this if you have special requirements\&. 
.PP
Requires \fCCH_USE_SEMAPHORES\fP\&. 
.RE
.PP

.SS "#define CH_USE_SEMSW   TRUE"

.PP
Atomic semaphore API\&. If enabled then the semaphores the \fCchSemSignalWait()\fP API is included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.PP
Requires \fCCH_USE_SEMAPHORES\fP\&. 
.RE
.PP

.SS "#define CH_USE_WAITEXIT   TRUE"

.PP
Threads synchronization APIs\&. If enabled then the \fCchThdWait()\fP function is included in the kernel\&.
.PP
\fBNote:\fP
.RS 4
The default is \fCTRUE\fP\&. 
.RE
.PP

.SS "#define CHPRINTF_USE_FLOAT   TRUE"

.SS "#define CORTEX_SIMPLIFIED_PRIORITY   TRUE"

.SS "#define IDLE_LOOP_HOOK()"
\fBValue:\fP
.PP
.nf
{                                                  \
  /* Idle loop code here\&.*/                                                 \
}
.fi
.PP
Idle Loop hook\&. This hook is continuously invoked by the idle thread loop\&. 
.SS "#define PORT_IDLE_THREAD_STACK_SIZE   64"

.SS "#define PORT_INT_REQUIRED_STACK   128"

.SS "#define SYSTEM_HALT_HOOK()"
\fBValue:\fP
.PP
.nf
{                                                \
  /* System halt code here\&.*/                                               \
}
.fi
.PP
System halt hook\&. This hook is invoked in case to a system halting error before the system is halted\&. 
.SS "#define SYSTEM_TICK_EVENT_HOOK()"
\fBValue:\fP
.PP
.nf
{                                          \
  /* System tick event code here\&.*/                                         \
}
.fi
.PP
System tick event hook\&. This hook is invoked in the system tick handler immediately after processing the virtual timers queue\&. 
.SS "#define THREAD_CONTEXT_SWITCH_HOOK(ntp, otp)"
\fBValue:\fP
.PP
.nf
{                              \
  /* System halt code here\&.*/                                               \
}
.fi
.PP
Context switch hook\&. This hook is invoked just before switching between threads\&. 
.SS "#define THREAD_EXT_EXIT_HOOK(tp)"
\fBValue:\fP
.PP
.nf
{                                          \
  /* Add threads finalization code here\&.*/                                  \
}
.fi
.PP
Threads finalization hook\&. User finalization code added to the \fCchThdExit()\fP API\&.
.PP
\fBNote:\fP
.RS 4
It is inserted into lock zone\&. 
.PP
It is also invoked when the threads simply return in order to terminate\&. 
.RE
.PP

.SS "#define THREAD_EXT_FIELDS   /* Add threads custom fields here\&.*/"

.PP
Threads descriptor structure extension\&. User fields added to the end of the \fCThread\fP structure\&. 
.SS "#define THREAD_EXT_INIT_HOOK(tp)"
\fBValue:\fP
.PP
.nf
{                                          \
  /* Add threads initialization code here\&.*/                                \
}
.fi
.PP
Threads initialization hook\&. User initialization code added to the \fCchThdInit()\fP API\&.
.PP
\fBNote:\fP
.RS 4
It is invoked from within \fCchThdInit()\fP and implicitly from all the threads creation APIs\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen from the source code\&.
